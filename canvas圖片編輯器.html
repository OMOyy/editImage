<html>
  <head>
    <title>Canvas 圖片編輯器</title>
    <script type="text/javascript">
      function draw() {       
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('backgroundImage');
        
        // 設定畫布尺寸
        canvas.width = 1200;
        canvas.height = 900;

        let backgroundImage = new Image();
        let overlayImages = [];
        const deletIcon = new Image();
        deletIcon.src = 'cross-circle.png';
        const zoomIcon = new Image();
        zoomIcon.src = 'arrow-up-right-and-arrow-down-left-from-center.png';

        let isDragging = false;
        let isClick = false;
        let selectedOverlayIndex = -1;
        let resizing = false;
        let rotationAngle = 0;
        let isImageLoaded = false;

        let initialWidth, initialHeight;
        let mouseX, mouseY;
        let scaleHandleRadius = 15;
        const deleteIconSize = 30;
        //畫矩形框
        let isRectangle = false; 
        let isDrawingRectangle = false;
        let rectangleStartX, rectangleStartY, rectangleEndX, rectangleEndY;
        //裁切
        let isCropping = false;
        let isCrop = false;
        let cropLeft, cropTop, cropDown, cropRight;        
        let cropRect = { x: 100, y: 100, width: 200, height: 150 }; 
        let cropX, cropY, cropWidth, cropHeight;   

        //文字編輯        
        let isText = false;
        let isDrawing = false;
        let fontSize = 36;

        function handleMouseDown(e) {
             mouseX = e.clientX - canvas.getBoundingClientRect().left;
             mouseY = e.clientY - canvas.getBoundingClientRect().top;
            //畫矩形框
            if(isRectangle){
                rectangleStartX = mouseX;
                rectangleStartY = mouseY;
                isDrawingRectangle = true;
                
            }else if(isCropping && isImageLoaded){   
                drawcheck((backgroundImage.width+canvas.getBoundingClientRect().left)/2,canvas.getBoundingClientRect().top);   
                //裁切功能 //let cropLeft, cropTop, cropDown, cropRight;  
                if( mouseX == cropX && mouseY >= backgroundImage.y && mouseY <= backgroundImage.y + backgroundImage.height ){
                            cropLeft = true;
                        }   
                        if( mouseX == cropX + backgroundImage.width && mouseY >= backgroundImage.y && mouseY <= backgroundImage.y + backgroundImage.height ){
                            cropRight = true;
                        }
                        if( mouseY == cropY && mouseX >= backgroundImage.x && mouseX <= backgroundImage.x + backgroundImage.width ){
                            cropTop = true;
                        }
                        if( mouseY == cropY + backgroundImage.height && mouseX >= backgroundImage.x && mouseX <= backgroundImage.x + backgroundImage.width ){
                            cropDown = true;
                        }              
                                                         
            }else {
                for (let i = overlayImages.length - 1; i >= 0; i--) {
                    const overlay = overlayImages[i];
                    //確定滑鼠在該圖檔上點擊
                    if (
                        mouseX >= overlay.x + deleteIconSize/2 &&
                        mouseX <= overlay.x + overlay.image.width - scaleHandleRadius &&
                        mouseY >= overlay.y  &&
                        mouseY <= overlay.y + overlay.image.height
                    ) {
                        isDragging = true;
                        selectedOverlayIndex = overlayImages.length - 1;
                        // 將被點擊的圖層移至陣列的最頂部
                        overlayImages.push(overlayImages.splice(i, 1)[0]); console.log("點擊");console.log(overlayImages);                   
                        isClick = true;//縮放功能 - 邊框
                        break;
                    }
                    //縮放功能
                    const scaledWidth = overlay.image.width;
                    const scaledHeight = overlay.image.height;
                    const scaleHandleX = overlay.x + scaledWidth;
                    const scaleHandleY = overlay.y + scaledHeight;
                    if (
                        mouseX >= scaleHandleX - scaleHandleRadius &&
                        mouseX <= scaleHandleX + scaleHandleRadius &&
                        mouseY >= scaleHandleY - scaleHandleRadius &&
                        mouseY <= scaleHandleY + scaleHandleRadius
                    ) {
                        resizing = true;
                        selectedOverlayIndex = i;                        
                        break;
                    }
                    //刪除功能
                    const deleteIconX = overlay.x;
                    const deleteIconY = overlay.y;
                    if (
                        mouseX >= deleteIconX - deleteIconSize/2  &&
                        mouseX <= deleteIconX + deleteIconSize/2  &&
                        mouseY >= deleteIconY - deleteIconSize/2  &&
                        mouseY <= deleteIconY + deleteIconSize/2 
                    ) {
                    // 在點擊到刪除圖案時，執行刪除該圖層的操作
                    overlayImages.splice(i, 1);
                    redrawCanvas();
                    break;
                    }
                }       
            }     
            redrawCanvas();
            
            //點擊後繪製 邊框、縮放按鈕、刪除按鈕
            if (isClick && selectedOverlayIndex !== -1){                 
                const overlay = overlayImages[selectedOverlayIndex];
                ctx.strokeStyle = 'black';
                ctx.strokeRect(overlay.x, overlay.y, overlay.image.width, overlay.image.height);
                const scaledWidth = overlay.image.width;
                const scaledHeight = overlay.image.height;
                initialWidth = overlay.image.width;
                initialHeight = overlay.image.height;
                drawScaleHandle(overlay.x + scaledWidth, overlay.y + scaledHeight);
                drawDeleteIcon( overlay.x,overlay.y);                
            }                        
        }
        
        function handleMouseUp(e) {            
            isDragging = false;
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top; 
            resizing = false;         
            selectedOverlayIndex = -1;
            cropLeft = false;
            cropRight = false;
            cropTop = false;
            cropDown = false;
            //畫矩形框
            if (isDrawingRectangle) {
                isDrawingRectangle = false;
                const mouseX = e.clientX - canvas.getBoundingClientRect().left;
                const mouseY = e.clientY - canvas.getBoundingClientRect().top;
                rectangleEndX = mouseX;
                rectangleEndY = mouseY;
                // Create a new overlay image from the drawn rectangle
                const rectCanvas = document.createElement('canvas');
                rectCanvas.width = Math.abs(rectangleEndX - rectangleStartX);
                rectCanvas.height = Math.abs(rectangleEndY - rectangleStartY);
                const rectCtx = rectCanvas.getContext('2d');
                drawRectangle(rectCtx,0, 0, rectCanvas.width, rectCanvas.height);                
                overlayImages.push({
                    number:j, 
                    image: rectCanvas, 
                    x: rectangleStartX, 
                    y: rectangleStartY, 
                    width:rectCanvas.width, 
                    height:rectCanvas.height,
                    isRectCanvas: true,
                 });
                j++;
                isRectangle = false;              
                redrawCanvas(); 
            }
        }
        
        function handleMouseMove(e) {                
            //移動功能
            if (isDragging && selectedOverlayIndex !== -1) {
                const overlay = overlayImages[selectedOverlayIndex];
                overlay.x = e.clientX - canvas.getBoundingClientRect().left - overlay.image.width / 2;
                overlay.y = e.clientY - canvas.getBoundingClientRect().top - overlay.image.height / 2;
                redrawCanvas();
            }else if (isDrawingRectangle) {//畫矩形框
                const mouseX = e.clientX - canvas.getBoundingClientRect().left;
                const mouseY = e.clientY - canvas.getBoundingClientRect().top;                     
                redrawCanvas();
                drawRectangle(ctx,rectangleStartX, rectangleStartY, mouseX, mouseY);            
            }else if(isCrop && isImageLoaded){//裁切功能
                mouseX = e.clientX - canvas.getBoundingClientRect().left;
                mouseY = e.clientY - canvas.getBoundingClientRect().top;
                const deltaX = mouseX - (backgroundImage.x + backgroundImage.width);
                const deltaY = mouseY - (backgroundImage.y + backgroundImage.height); 
                const deltaX2 = mouseX - backgroundImage.x ;
                const deltaY2 = mouseY - backgroundImage.y ; 
                cropLeft = backgroundImage.x;
                cropRight = backgroundImage.x + backgroundImage.width;
                cropTop = backgroundImage.y;
                cropDown = backgroundImage.y + backgroundImage.height;
                if(cropLeft){
                    cropX = cropX + deltaX2;
                }else if(cropRight){
                    cropWidth = cropWidth + deltaX;                    
                }else if(cropTop){
                    cropY = cropY + deltaY2;
                }else if(cropDown){
                    cropHeight = cropHeight + deltaY;
                }
                drawCropRect(cropX, cropY, cropWidth, cropHeight);
            }
            //縮放功能 
            if (resizing && selectedOverlayIndex !== -1) {
                mouseX = e.clientX - canvas.getBoundingClientRect().left;
                mouseY = e.clientY - canvas.getBoundingClientRect().top;
                const overlay = overlayImages[selectedOverlayIndex];
                const deltaX = mouseX - (overlay.x + overlay.image.width);
                const deltaY = mouseY - (overlay.y + overlay.image.height);                
                //const newWidth = initialWidth + deltaX;
                //const newHeight = initialHeight + deltaY;
                let newWidth, newHeight;
                const aspectRatio = initialWidth / initialHeight;
                newHeight = initialHeight + deltaY;
                newWidth = newHeight * aspectRatio;//只能等比例放大縮小

                //旋轉功能
                // 計算用戶拖動的角度
                //rotationAngle = Math.atan2(mouseX, mouseY);  //要以哪裡為中心點?

                //因為一直無法解決[不可動到retcanvas長寬]的問題，所以用爆理解法刪除圖層重新推一個新的長寬上去
                if(overlay.isRectCanvas && resizing){
                    overlayImages.splice(selectedOverlayIndex, 1);
                    const rectCanvas = document.createElement('canvas');
                    if(newWidth > 50){
                        rectCanvas.width = newWidth;
                        rectCanvas.height = newHeight;
                        const rectCtx = rectCanvas.getContext('2d');
                        drawRectangle(rectCtx,0, 0, rectCanvas.width, rectCanvas.height);                
                        overlayImages.push({
                            number:j, 
                            image: rectCanvas, 
                            x: overlay.x, 
                            y: overlay.y, 
                            width:rectCanvas.width, 
                            height:rectCanvas.height,
                            isRectCanvas: true,
                        });
                        j++;
                    }                    
               }else if(overlay.isText && resizing){
                    overlayImages.splice(selectedOverlayIndex, 1);
                    const textCanvas = document.createElement('canvas');
                    if(newWidth > 50){
                        textCanvas.width = newWidth;
                        textCanvas.height = newHeight;
                        const textCtx = textCanvas.getContext('2d');
                        textCtx.beginPath();
                        textCtx.font = `${newHeight}px 微软雅黑`;
                        textCtx.fillStyle = "black";
                        textCtx.textBaseline = "top";
                        textCtx.textAlign = "left";
                        textCtx.fillText(overlay.text, 1, 1);  
                        textCtx.closePath();
                        overlayImages.push({
                            number:j, 
                            image: textCanvas, 
                            x: overlay.x, 
                            y: overlay.y, 
                            width:textCanvas.width, 
                            height:textCanvas.height,
                            isText:true,
                            text:overlay.text,
                        });     
                        j++;
                    }   
               }else{
                if(newWidth > 50){
                    overlay.image.width = newWidth;
                    overlay.image.height = newHeight;
                }
                }                            
                redrawCanvas();
            }                       
        }        
        /*-----------------------------------------------------Function-----------------------------------------------------*/
        //繪製圖像於畫布上
        function drawImageOnCanvas(image, x, y, width, height) {
            ctx.drawImage(image, x, y, width, height);
        }
        //清空畫布
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        function redrawCanvas() {
            clearCanvas();
            // 計算等比例缩放比例
            const scale = Math.min(canvas.width / backgroundImage.width, canvas.height / backgroundImage.height);
            const scaledWidth = backgroundImage.width * scale;
            let scaledHeight = backgroundImage.height * scale;
            if(backgroundImage.height < canvas.height){
                scaledHeight = backgroundImage.height;
            }      
            drawImageOnCanvas(backgroundImage, 0, 0, scaledWidth, scaledHeight);           
            for (const overlay of overlayImages) {    
                //drawRotate(overlay);                              
                const overlayWidth = overlay.image.width;
                const overlayHeight = overlay.image.height;        
                drawImageOnCanvas(overlay.image, overlay.x, overlay.y, overlayWidth, overlayHeight);                 
            }
        }
        function drawRotate(overlay){                
                // 將圖層的中心點設置為旋轉的軸心
                // 設定旋轉中心為圖像的中心
                const centerX = overlay.image.width / 2;
                const centerY = overlay.image.height / 2;

                ctx.translate(centerX, centerY);
                ctx.rotate((Math.PI / 180) * rotationAngle);
                ctx.clearRect(overlay.x,overlay.y,overlay.image.width, overlay.image.height);
                // 計算旋轉後的圖像區域的邊界框
                const rotatedBoundingBox = getRotatedBoundingBox(centerX, centerY, overlay.image.width, overlay.image.height, (Math.PI / 180) * 45);

                // 計算新的寬度和高度
                const rotatedWidth = rotatedBoundingBox.maxX - rotatedBoundingBox.minX;
                const rotatedHeight = rotatedBoundingBox.maxY - rotatedBoundingBox.minY;     
                overlay.image.width =  rotatedWidth;
                overlay.image.height = rotatedHeight;
                ctx.drawImage(overlay.image, 0, 0, overlay.image.width, overlay.image.height);
                // 恢復坐標系統
                ctx.rotate((Math.PI / 180) * -rotationAngle);
                ctx.translate(-centerX, -centerY);  
                
        }
        function getRotatedBoundingBox(centerX, centerY, width, height, angle) {
            const radians = angle;
            const cos = Math.abs(Math.cos(radians));
            const sin = Math.abs(Math.sin(radians));

            const newWidth = width * cos + height * sin;
            const newHeight = width * sin + height * cos;

            const minX = centerX - newWidth / 2;
            const minY = centerY - newHeight / 2;
            const maxX = centerX + newWidth / 2;
            const maxY = centerY + newHeight / 2;

            return { minX, minY, maxX, maxY };
        }
        function cropImage(){
            isCropping = true;                 
        }
        // 繪製可調整的裁切框
        function drawCropRect(cropX, cropY, cropWidth, cropHeight) {
            // 繪製遮罩
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, backgroundImage.width, backgroundImage.height);       
            // 將 globalCompositeOperation 設置為 'destination-out'
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(cropX, cropY, cropWidth, cropHeight);
            // 在裁切框的位置和尺寸上繪製一個白色的矩形
            ctx.fillStyle = 'white';
            ctx.fillRect(cropX, cropY, cropWidth, cropHeight);

            // 還原 globalCompositeOperation 為預設值
            ctx.globalCompositeOperation = 'source-over';
        }
        function zoomInImage(){
            if(isImageLoaded){
                const scale =  100;
                canvas.width = canvas.width + scale;
                canvas.height = canvas.height + scale;
                redrawCanvas();                
            }            
        }
        function zoomOutImage(){
            if(isImageLoaded){
                const scale =  100;
                canvas.width = canvas.width - scale;
                canvas.height = canvas.height - scale;
                redrawCanvas();
            }            
        }
         //編輯文字
         function EditText (e) {   
            isText = true;   
            isRectangle = false;
            openModal(); 
        };        
        function drawText(text, x, y){            
            const textCanvas = document.createElement('canvas');//沒有設置長寬的話預設長寬是 150 300
            const textCtx = textCanvas.getContext('2d');
            textCtx.beginPath();
            textCtx.font = `${fontSize}px 微软雅黑`;
            textCtx.fillStyle = "black";
            textCtx.textBaseline = "top";
            textCtx.textAlign = "left";
            textCtx.fillText(text, 1, 1);  
            const textwidth = textCtx.measureText(text).width;
            textCtx.closePath();
            // 畫布大小似乎只能在一開始設置，所以再設一個畫布調整圖層長寬
            const textCanvas2 = document.createElement('canvas');
            textCanvas2.width = textwidth;//只能放在這個位置
            textCanvas2.height = fontSize;
            const textCtx2 = textCanvas2.getContext('2d');
            textCtx2.beginPath();
            textCtx2.font = `${fontSize}px 微软雅黑`;
            textCtx2.fillStyle = "black";
            textCtx2.textBaseline = "top";
            textCtx2.textAlign = "left";
            textCtx2.fillText(text, 1, 1);  
            textCtx2.closePath();
            // 將 textCanvas 轉換成 Data URL
            //const dataURL = textCanvas2.toDataURL();
            //const textimage = new Image();
            //textimage.src = dataURL;
            overlayImages.push({
                    number:j, 
                    image: textCanvas2, 
                    x: x, 
                    y: y, 
                    width:textCanvas2.width+1, 
                    height:textCanvas2.height+1,
                    isText:true,
                    text:text,
                 });
                j++;             
            redrawCanvas();
            
        };     
        function openModal() {
            document.getElementById('myModal').style.display = 'block';
        }     
        function addText() {
            const textInput = document.getElementById('textInput');
            const text = textInput.value.trim();
            // 將文字繪製成圖層
            drawText(text,canvas.width/2,canvas.height/2);
            // 關閉模態對話框
            isText = false;   
            document.getElementById('myModal').style.display = 'none';
            // 清空輸入框
            textInput.value = '';
        }       
        function cancelText(){
            isText = false;   
            document.getElementById('myModal').style.display = 'none';
            textInput.value = '';
        }
        //畫矩形框        
        function IsdrawRectangle(){
            isRectangle = true;
            isText = false;   
        }
        function drawRectangle(canvas,startX, startY, endX, endY) {
            canvas.beginPath();
            canvas.rect(startX, startY, endX - startX, endY - startY);
            canvas.strokeStyle = 'red';
            canvas.lineWidth = 2;
            canvas.stroke();
            canvas.closePath();
        }
        //加上active
        
        function saveImage() {
            var dataURL = canvas.toDataURL('image/png');
            var link = document.createElement('a');
            link.href = dataURL;
            link.download = 'canvas_image.png';
            //開始下載
            link.click();
        }
        /*---------------------------------------------------------------------------------------------------------------------*/                
        /*------------------------------------------------------功能圖示按鈕繪畫---------------------------------------------------------------------------*/        
        function drawScaleHandle(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, scaleHandleRadius, 0, Math.PI * 2);//arc(x, y, radius, startAngle, endAngle, anticlockwise) 
            ctx.fillStyle = 'white';
            ctx.fill();
            drawImageOnCanvas(zoomIcon, x-(scaleHandleRadius/2), y-(scaleHandleRadius/2), scaleHandleRadius, scaleHandleRadius);
            ctx.closePath();
        }

        function drawDeleteIcon(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, deleteIconSize/2, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            drawImageOnCanvas(deletIcon, x-(deleteIconSize/2), y-(deleteIconSize/2), deleteIconSize, deleteIconSize);
            ctx.closePath();
        }

        function deleteSelectedOverlay() {
            if (selectedOverlayIndex !== -1) {
                overlayImages.splice(selectedOverlayIndex, 1);
                selectedOverlayIndex = -1;
                redrawCanvas();
            }
        }
        function drawcheck(x,y){

        }
        /*--------------------------------------------------------------------------------------------------------------------------------------------------*/
        backgroundImage.onload = function () {            
            clearCanvas();          
            //drawImageOnCanvas(backgroundImage, 0, 0, scaledWidth, scaledHeight);console.log(scaledHeight);
            redrawCanvas(); 
            isImageLoaded = true; 
        };

        overlayImage.onload = function () {
            drawImageOnCanvas(overlayImage, 50, 50, overlayImage.width, overlayImage.height); 
        };

        document.getElementById('backgroundImage').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                backgroundImage.src = URL.createObjectURL(file);// 設定圖像的src為選擇的圖像文件                
            }
        });
        //圖層
        var j = 0;
        document.getElementById('overlayImage').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                const newOverlay = new Image();
                newOverlay.src = URL.createObjectURL(file);
                overlayImages.push({number:j, image: newOverlay, x: 50, y: 50 });j++;
                newOverlay.onload = function () {
                    redrawCanvas();
                };
        }});
        //裁切功能
        document.getElementById('cropImage').addEventListener('click', cropImage);
        document.getElementById('zoomIn').addEventListener('click', zoomInImage);
        document.getElementById('zoomOut').addEventListener('click', zoomOutImage);
        //文字編輯功能
        document.getElementById('drawTextButton').addEventListener('click',EditText);
        document.getElementById('addText').addEventListener('click',addText);
        document.getElementById('cancelText').addEventListener('click',cancelText);
        //畫矩形框
        document.getElementById('drawRectangle').addEventListener('click',IsdrawRectangle);

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mousemove', handleMouseMove);
        //canvas.addEventListener('click', handleMouseClick);
        //canvas.addEventListener('mouseenter', handleMouseEnter);
        //canvas.addEventListener('mouseleave', handleMouseLeave);

        /*做一點樣式動畫*//*
        const menu = body.querySelector(".menu");
        const menuItems = menu.querySelectorAll(".menu__item");
        const menuBorder = menu.querySelector(".menu__border");
        let activeItem = menu.querySelector(".active");
        function clickItem(item, index) {

            //menu.style.removeProperty("--timeOut");

            if (activeItem == item) return;

            if (activeItem) {
                activeItem.classList.remove("active");
            }


            item.classList.add("active");
            //body.style.backgroundColor = bgColorsBody[index];
            activeItem = item;
            offsetMenuBorder(activeItem, menuBorder);
            }

        function offsetMenuBorder(element, menuBorder) {
            const offsetActiveItem = element.getBoundingClientRect();
            const left = Math.floor(offsetActiveItem.left - menu.offsetLeft - (menuBorder.offsetWidth  - offsetActiveItem.width) / 2) +  "px";
            menuBorder.style.transform = `translate3d(${left}, 0 , 0)`;
        }

offsetMenuBorder(activeItem, menuBorder);

menuItems.forEach((item, index) => {

    item.addEventListener("click", () => clickItem(item, index));

})*/
        }
    </script>
<style type="text/css">
    canvas {
        border: 1px solid white;
    }
    body{
        margin: 8px 30px !important;
        min-width: 825px;
    }
    .button{
        font-weight: 600;
        cursor: pointer;
        vertical-align: middle;
        letter-spacing: .3px;
        text-align: center;
        font-family: 'Noto Sans', sans-serif;
        width: 150px;
        height: 35px;letter-spacing: 2px;cursor: pointer;padding: 0;
        outline: none;
    }
    .menu__border{
        content: "";
        z-index: -1;
        width: 4.2em;
        height: 4.2em;
        border-radius: 50%;
        position: absolute;
        transform: scale(0);
        transition: background-color var(--duration), transform var(--duration);
      }
    #zoomIn{
        position:relative;
    }
    #zoomIn:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '底圖放大';
    }
    #zoomOut{
        position:relative;
    }
    #zoomOut:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '底圖縮小';
    }
    #drawTextButton{
        position:relative;
    }
    #drawTextButton:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '插入文字';
    }
    #drawRectangle{
        position:relative;
    }
    #drawRectangle:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '繪製矩形';
    }
    </style>
  </head>
  <body onload="draw();" >
    <!--排版一下-->
    <div style="margin: 0px auto 20px auto;max-width:1200px;">
        <div style="width: 100%;height:100%;margin: 20px;    ">
            <div style="padding: 0px; vertical-align: middle;align-items: center;justify-content: space-between!important; display: flex; ">
                <div style="width: 50%; display: flex;">
                    <svg xmlns="http://www.w3.org/2000/svg"style=" color: #fbbb3c; padding: 25px;" width="40" height="40" fill="currentColor" class="bi bi-highlighter" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M11.096.644a2 2 0 0 1 2.791.036l1.433 1.433a2 2 0 0 1 .035 2.791l-.413.435-8.07 8.995a.5.5 0 0 1-.372.166h-3a.5.5 0 0 1-.234-.058l-.412.412A.5.5 0 0 1 2.5 15h-2a.5.5 0 0 1-.354-.854l1.412-1.412A.5.5 0 0 1 1.5 12.5v-3a.5.5 0 0 1 .166-.372l8.995-8.07.435-.414Zm-.115 1.47L2.727 9.52l3.753 3.753 7.406-8.254-2.905-2.906Zm3.585 2.17.064-.068a1 1 0 0 0-.017-1.396L13.18 1.387a1 1 0 0 0-1.396-.018l-.068.065 2.85 2.85ZM5.293 13.5 2.5 10.707v1.586L3.707 13.5h1.586Z"/>
                      </svg><h1 style="padding-top: 0; color: #fbbb3c;font-family: 'Noto Sans', sans-serif;"> Image Editor</h1>
                </div>                
                <div style="padding: 25px;width: 50%;display: flex; ">
                    <div >
                        <button class="button" type="button" style="background-color: white; border:1px solid #fbbb3c;border-radius:  0.3rem;text-align: center;margin:0px 20px ;">SAVE</button>
                        <button class="button"onclick="saveImage()" type="button" style="background-color:#fbbb3c;border: none; border-radius:  0.3rem;color: black;text-align: center;">完成輸出</button>
                    </div>          
                </div>                
            </div>
            <div style="display: flex;    width: 20%;height: 18px;">                      
                <div class="menu" style="height: 40px; display: flex;margin:25px 0px 25px 0px;">
                    <div style="padding: 0px 25px; display: flex;flex-direction: column!important; background-color: white;">
                        <div style="display: flex; align-items: center;">
                            <button type="button"style="background-color:#fbbb3c;border: none; border-radius: 5px;color: black;text-align: center;align-items: center;">
                                <label><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-plus-square-dotted" viewBox="0 0 16 16">
                                    <path d="M2.5 0c-.166 0-.33.016-.487.048l.194.98A1.51 1.51 0 0 1 2.5 1h.458V0H2.5zm2.292 0h-.917v1h.917V0zm1.833 0h-.917v1h.917V0zm1.833 0h-.916v1h.916V0zm1.834 0h-.917v1h.917V0zm1.833 0h-.917v1h.917V0zM13.5 0h-.458v1h.458c.1 0 .199.01.293.029l.194-.981A2.51 2.51 0 0 0 13.5 0zm2.079 1.11a2.511 2.511 0 0 0-.69-.689l-.556.831c.164.11.305.251.415.415l.83-.556zM1.11.421a2.511 2.511 0 0 0-.689.69l.831.556c.11-.164.251-.305.415-.415L1.11.422zM16 2.5c0-.166-.016-.33-.048-.487l-.98.194c.018.094.028.192.028.293v.458h1V2.5zM.048 2.013A2.51 2.51 0 0 0 0 2.5v.458h1V2.5c0-.1.01-.199.029-.293l-.981-.194zM0 3.875v.917h1v-.917H0zm16 .917v-.917h-1v.917h1zM0 5.708v.917h1v-.917H0zm16 .917v-.917h-1v.917h1zM0 7.542v.916h1v-.916H0zm15 .916h1v-.916h-1v.916zM0 9.375v.917h1v-.917H0zm16 .917v-.917h-1v.917h1zm-16 .916v.917h1v-.917H0zm16 .917v-.917h-1v.917h1zm-16 .917v.458c0 .166.016.33.048.487l.98-.194A1.51 1.51 0 0 1 1 13.5v-.458H0zm16 .458v-.458h-1v.458c0 .1-.01.199-.029.293l.981.194c.032-.158.048-.32.048-.487zM.421 14.89c.183.272.417.506.69.689l.556-.831a1.51 1.51 0 0 1-.415-.415l-.83.556zm14.469.689c.272-.183.506-.417.689-.69l-.831-.556c-.11.164-.251.305-.415.415l.556.83zm-12.877.373c.158.032.32.048.487.048h.458v-1H2.5c-.1 0-.199-.01-.293-.029l-.194.981zM13.5 16c.166 0 .33-.016.487-.048l-.194-.98A1.51 1.51 0 0 1 13.5 15h-.458v1h.458zm-9.625 0h.917v-1h-.917v1zm1.833 0h.917v-1h-.917v1zm1.834-1v1h.916v-1h-.916zm1.833 1h.917v-1h-.917v1zm1.833 0h.917v-1h-.917v1zM8.5 4.5a.5.5 0 0 0-1 0v3h-3a.5.5 0 0 0 0 1h3v3a.5.5 0 0 0 1 0v-3h3a.5.5 0 0 0 0-1h-3v-3z"/>
                                  </svg>上傳底圖<input type="file" id="backgroundImage" accept="image/*"style="width:1px;height:1px;"></label>
                            </button>                    
                        </div>
                        <div  style="padding: 10px;border:0px solid #fbbb3c; border-radius:  0.3rem;">
                            <label>
                                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-images" viewBox="0 0 16 16">
                                    <path d="M4.502 9a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"/>
                                    <path d="M14.002 13a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2V5A2 2 0 0 1 2 3a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v8a2 2 0 0 1-1.998 2zM14 2H4a1 1 0 0 0-1 1h9.002a2 2 0 0 1 2 2v7A1 1 0 0 0 15 11V3a1 1 0 0 0-1-1zM2.002 4a1 1 0 0 0-1 1v8l2.646-2.354a.5.5 0 0 1 .63-.062l2.66 1.773 3.71-3.71a.5.5 0 0 1 .577-.094l1.777 1.947V5a1 1 0 0 0-1-1h-10z"/>
                                  </svg>
                                <input type="file" id="overlayImage" accept="image/*"style="width:0px;height:0px;">
                                </label>    
                        </div>
                        <div style="padding: 10px;">
                            <label id="zoomIn"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-zoom-in" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                                <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                                <path fill-rule="evenodd" d="M6.5 3a.5.5 0 0 1 .5.5V6h2.5a.5.5 0 0 1 0 1H7v2.5a.5.5 0 0 1-1 0V7H3.5a.5.5 0 0 1 0-1H6V3.5a.5.5 0 0 1 .5-.5z"/>
                              </svg></label>       
                        </div>
                        <div  style="padding: 10px;">
                            <label id="zoomOut"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-zoom-out" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                                <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                                <path fill-rule="evenodd" d="M3 6.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5z"/>
                              </svg></label>       
                        </div>     
                        <div class="menu__item" style="padding: 10px;">
                            <label id="cropImage"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-scissors" viewBox="0 0 16 16">
                                <path d="M3.5 3.5c-.614-.884-.074-1.962.858-2.5L8 7.226 11.642 1c.932.538 1.472 1.616.858 2.5L8.81 8.61l1.556 2.661a2.5 2.5 0 1 1-.794.637L8 9.73l-1.572 2.177a2.5 2.5 0 1 1-.794-.637L7.19 8.61 3.5 3.5zm2.5 10a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0zm7 0a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0z"/>
                              </svg></label>       
                        </div>
                        <div class="menu__item" style="padding: 10px;">
                            <label><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-highlighter" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M11.096.644a2 2 0 0 1 2.791.036l1.433 1.433a2 2 0 0 1 .035 2.791l-.413.435-8.07 8.995a.5.5 0 0 1-.372.166h-3a.5.5 0 0 1-.234-.058l-.412.412A.5.5 0 0 1 2.5 15h-2a.5.5 0 0 1-.354-.854l1.412-1.412A.5.5 0 0 1 1.5 12.5v-3a.5.5 0 0 1 .166-.372l8.995-8.07.435-.414Zm-.115 1.47L2.727 9.52l3.753 3.753 7.406-8.254-2.905-2.906Zm3.585 2.17.064-.068a1 1 0 0 0-.017-1.396L13.18 1.387a1 1 0 0 0-1.396-.018l-.068.065 2.85 2.85ZM5.293 13.5 2.5 10.707v1.586L3.707 13.5h1.586Z"/>
                              </svg></label>
                        </div>      
                        <div class="menu__item" style="padding: 10px;">
                            <label id="drawTextButton"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-fonts" viewBox="0 0 16 16">
                                <path d="M12.258 3h-8.51l-.083 2.46h.479c.26-1.544.758-1.783 2.693-1.845l.424-.013v7.827c0 .663-.144.82-1.3.923v.52h4.082v-.52c-1.162-.103-1.306-.26-1.306-.923V3.602l.431.013c1.934.062 2.434.301 2.693 1.846h.479L12.258 3z"/>
                              </svg></label>
                        </div>
                        <div class="menu__item" style="padding: 10px;">
                            <label id="drawRectangle"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-square" viewBox="0 0 16 16">
                                <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                              </svg></label>
                        </div>
                        <div class="menu__item" style="padding: 10px;">
                            <label id="chooseColor"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-palette-fill" viewBox="0 0 16 16">
                                <path d="M12.433 10.07C14.133 10.585 16 11.15 16 8a8 8 0 1 0-8 8c1.996 0 1.826-1.504 1.649-3.08-.124-1.101-.252-2.237.351-2.92.465-.527 1.42-.237 2.433.07M8 5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m4.5 3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3M5 6.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3"/>
                              </svg></label>
                        </div>
                        <div class="menu__border"></div>                        
                    </div>
                </div>
                
            </div>   
            <div style="width: 80%; margin:0px 80px;"><canvas id="myCanvas"style="border: 1px solid rgba(0,0,0,.2);border-radius:  0.3rem;max-width:100%;"  ></canvas></div>        
            
            <div style="margin: 15rem auto;max-width: 500px;"><!--待處理  這一塊會擋到畫布-->
                <div  id="myModal"  style="position: fixed;top: 15rem ;display: none;z-index: 1060; text-align: center;   ">
                    <div style="position: relative;display: flex;flex-direction: column;width: 100%;pointer-events: auto;background-color: #fff;
                    background-clip: padding-box;
                    border: 1px solid rgba(0,0,0,.2);
                    border-radius: 0.3rem;padding: 0.3rem;
                    outline: 0;">
                        <div style="padding: 0.3rem;"><label for="textInput">請輸入文字：</label></div>
                        <div><input type="text" id="textInput"></div>
                        <div><button id="addText">確定</button></div>
                        <div><button id="cancelText">取消</button></div>
                    </div>
                    
                </div>
            <!--插入游標圖案--不使用了
            <div class="mouseImg">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor-text" viewBox="0 0 16 16">
                    <path d="M5 2a.5.5 0 0 1 .5-.5c.862 0 1.573.287 2.06.566.174.099.321.198.44.286.119-.088.266-.187.44-.286A4.165 4.165 0 0 1 10.5 1.5a.5.5 0 0 1 0 1c-.638 0-1.177.213-1.564.434a3.49 3.49 0 0 0-.436.294V7.5H9a.5.5 0 0 1 0 1h-.5v4.272c.1.08.248.187.436.294.387.221.926.434 1.564.434a.5.5 0 0 1 0 1 4.165 4.165 0 0 1-2.06-.566A4.561 4.561 0 0 1 8 13.65a4.561 4.561 0 0 1-.44.285 4.165 4.165 0 0 1-2.06.566.5.5 0 0 1 0-1c.638 0 1.177-.213 1.564-.434.188-.107.335-.214.436-.294V8.5H7a.5.5 0 0 1 0-1h.5V3.228a3.49 3.49 0 0 0-.436-.294A3.166 3.166 0 0 0 5.5 2.5.5.5 0 0 1 5 2zm3.352 1.355zm-.704 9.29z"/>
                  </svg>
            </div>-->
            </div>
        </div>
    </div>

    

    

    
  </body>
</html>