<html>
  <head>
    <title>Canvas 圖片編輯器</title>
    <script type="text/javascript">
      function draw() {       
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('backgroundImage');
        
        // 設定畫布尺寸
        canvas.width = canvas.clientWidth;
        canvas.height = 500;//預設畫布
        DrawNoImage();
        // 提高讀取操作的效率
        ctx.canvas.willReadFrequently = true;

        let backgroundImage = new Image();
        let overlayImages = [];
        const deletIcon = new Image();
        deletIcon.src = 'cross-circle.png';
        const zoomIcon = new Image();
        zoomIcon.src = 'arrow-up-right-and-arrow-down-left-from-center.png';

        let isDragging = false;
        let isClick = false;
        let selectedOverlayIndex = -1;
        let resizing = false;
        let rotationAngle = 0;
        let isImageLoaded = false;
        addOverlayImage();
        
        let initialWidth, initialHeight;
        let mouseX, mouseY;
        let scaleHandleRadius = 15;
        const deleteIconSize = 30;
        //畫矩形框
        let isRectangle = false; 
        let isDrawingRectangle = false;
        let rectangleStartX, rectangleStartY, rectangleEndX, rectangleEndY;
        //裁切
        let isCropping = false;
        let isCrop = false;
        let cropLeft, cropTop, cropDown, cropRight;        
        let cropRect = { x: 100, y: 100, width: 200, height: 150 }; 
        let cropX, cropY, cropWidth, cropHeight;   

        //文字編輯        
        let isText = false;
        let isDrawing = false;
        let fontSize = 36;
        //繪圖
        let isdrawLine = false;
        let drawLineX , drawLineY;
        let drawLineEndX, drawLineEndY;
        let isDrawingLine = false;
        let check = false;
        let checkIconWidth = 80;
        let checkIconHeight = 30;
        let boundingBox;
        let i=0;
        const points = [];
        //歷史紀錄
        let history = [];
        let historyPointer = -1;

        //顏色
        let color ;

        function handleMouseDown(e) {
             mouseX = e.clientX - canvas.getBoundingClientRect().left;
             mouseY = e.clientY - canvas.getBoundingClientRect().top;
            //繪圖
            if(isdrawLine){
                drawLineX = mouseX;
                drawLineY = mouseY;
                isDrawingLine = true;
            }else if(isRectangle){//畫矩形框
                rectangleStartX = mouseX;
                rectangleStartY = mouseY;
                isDrawingRectangle = true;
                
            }else {
                for (let i = overlayImages.length - 1; i >= 0; i--) {
                    const overlay = overlayImages[i];console.log(overlayImages);                       
                    //確定滑鼠在該圖檔上點擊
                    if (
                        mouseX >= overlay.x + deleteIconSize/2 &&
                        mouseX <= overlay.x + overlay.image.width - scaleHandleRadius &&
                        mouseY >= overlay.y  &&
                        mouseY <= overlay.y + overlay.image.height
                    ) {
                        isDragging = true;
                        selectedOverlayIndex = overlayImages.length - 1;
                        // 將被點擊的圖層移至陣列的最頂部
                        overlayImages.push(overlayImages.splice(i, 1)[0]);
                        isClick = true;//縮放功能 - 邊框
                        break;
                    }
                    //縮放功能
                    const scaledWidth = overlay.image.width;
                    const scaledHeight = overlay.image.height;
                    const scaleHandleX = overlay.x + scaledWidth;
                    const scaleHandleY = overlay.y + scaledHeight;
                    if (
                        mouseX >= scaleHandleX - scaleHandleRadius &&
                        mouseX <= scaleHandleX + scaleHandleRadius &&
                        mouseY >= scaleHandleY - scaleHandleRadius &&
                        mouseY <= scaleHandleY + scaleHandleRadius
                    ) {
                        resizing = true;
                        selectedOverlayIndex = i;                        
                        break;
                    }
                    //刪除功能
                    const deleteIconX = overlay.x;
                    const deleteIconY = overlay.y;
                    if (
                        mouseX >= deleteIconX - deleteIconSize/2  &&
                        mouseX <= deleteIconX + deleteIconSize/2  &&
                        mouseY >= deleteIconY - deleteIconSize/2  &&
                        mouseY <= deleteIconY + deleteIconSize/2 
                    ) {
                    // 在點擊到刪除圖案時，執行刪除該圖層的操作
                    overlayImages.splice(i, 1);
                    redrawCanvas();
                    break;
                    }
                }       
            } 
            //if(isImageLoaded){    
            //redrawCanvas();}
            
            //點擊後繪製 邊框、縮放按鈕、刪除按鈕
            if (isClick && selectedOverlayIndex !== -1){                 
                const overlay = overlayImages[selectedOverlayIndex];
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeRect(overlay.x, overlay.y, overlay.image.width, overlay.image.height);
                const scaledWidth = overlay.image.width;
                const scaledHeight = overlay.image.height;
                initialWidth = overlay.image.width;
                initialHeight = overlay.image.height;
                drawScaleHandle(overlay.x + scaledWidth, overlay.y + scaledHeight);
                drawDeleteIcon( overlay.x,overlay.y);                
            }                        
        }
        
        function handleMouseUp(e) {            
            isDragging = false;
            const mouseX = e.clientX - canvas.getBoundingClientRect().left;
            const mouseY = e.clientY - canvas.getBoundingClientRect().top; 
            resizing = false;         
            selectedOverlayIndex = -1;
            cropLeft = false;
            cropRight = false;
            cropTop = false;
            cropDown = false;            
            //畫矩形框
            if (isDrawingRectangle) {
                isDrawingRectangle = false;
                const mouseX = e.clientX - canvas.getBoundingClientRect().left;
                const mouseY = e.clientY - canvas.getBoundingClientRect().top;
                rectangleEndX = mouseX;
                rectangleEndY = mouseY;
                // Create a new overlay image from the drawn rectangle
                const rectCanvas = document.createElement('canvas');
                rectCanvas.width = Math.abs(rectangleEndX - rectangleStartX);
                rectCanvas.height = Math.abs(rectangleEndY - rectangleStartY);
                const rectCtx = rectCanvas.getContext('2d');
                drawRectangle(rectCtx,0, 0, rectCanvas.width, rectCanvas.height);                
                overlayImages.push({
                    number:j, 
                    image: rectCanvas, 
                    x: rectangleStartX, 
                    y: rectangleStartY, 
                    width:rectCanvas.width, 
                    height:rectCanvas.height,
                    isRectCanvas: true,
                 });
                j++;
                isRectangle = false;
                ButtonActive();          
                redrawCanvas();    
            }else if(isDrawingLine){//繪圖功能
                drawLine(ctx, drawLineX, drawLineY, mouseX, mouseY); 
                drawLineOnTempCanvas(drawLineX, drawLineY, mouseX, mouseY);                               
                drawLineX = - canvas.getBoundingClientRect().left;
                drawLineY = - canvas.getBoundingClientRect().top;
                isDrawingLine = false;   
                drawLineEndX = mouseX;
                drawLineEndY = mouseY;
                saveState();                                  
            }            
        }
        
        function handleMouseMove(e) {                
            //移動功能
            if (isDragging && selectedOverlayIndex !== -1) {
                const overlay = overlayImages[selectedOverlayIndex];
                overlay.x = e.clientX - canvas.getBoundingClientRect().left - overlay.image.width / 2;
                overlay.y = e.clientY - canvas.getBoundingClientRect().top - overlay.image.height / 2;
                redrawCanvas();
            }else if (isDrawingRectangle) {//畫矩形框
                mouseX = e.clientX - canvas.getBoundingClientRect().left;
                mouseY = e.clientY - canvas.getBoundingClientRect().top;                     
                redrawCanvas();
                drawRectangle(ctx,rectangleStartX, rectangleStartY, mouseX, mouseY);            
            }else if(isCrop && isImageLoaded){//裁切功能
                mouseX = e.clientX - canvas.getBoundingClientRect().left;
                mouseY = e.clientY - canvas.getBoundingClientRect().top;
                const deltaX = mouseX - (backgroundImage.x + backgroundImage.width);
                const deltaY = mouseY - (backgroundImage.y + backgroundImage.height); 
                const deltaX2 = mouseX - backgroundImage.x ;
                const deltaY2 = mouseY - backgroundImage.y ; 
                cropLeft = backgroundImage.x;
                cropRight = backgroundImage.x + backgroundImage.width;
                cropTop = backgroundImage.y;
                cropDown = backgroundImage.y + backgroundImage.height;
                if(cropLeft){
                    cropX = cropX + deltaX2;
                }else if(cropRight){
                    cropWidth = cropWidth + deltaX;                    
                }else if(cropTop){
                    cropY = cropY + deltaY2;
                }else if(cropDown){
                    cropHeight = cropHeight + deltaY;
                }
                drawCropRect(cropX, cropY, cropWidth, cropHeight);
            }else if(isDrawingLine){//繪圖功能
                mouseX = e.clientX - canvas.getBoundingClientRect().left ;
                mouseY = e.clientY - canvas.getBoundingClientRect().top ;
                drawLine(ctx, drawLineX, drawLineY, mouseX, mouseY);
                drawLineOnTempCanvas(drawLineX, drawLineY, mouseX, mouseY);
                drawLineX = mouseX;
                drawLineY = mouseY;
                points.push({ x: mouseX, y: mouseY });
            }
            //縮放功能 
            if (resizing && selectedOverlayIndex !== -1) {
                mouseX = e.clientX - canvas.getBoundingClientRect().left;
                mouseY = e.clientY - canvas.getBoundingClientRect().top;
                const overlay = overlayImages[selectedOverlayIndex];
                const deltaX = mouseX - (overlay.x + overlay.image.width);
                const deltaY = mouseY - (overlay.y + overlay.image.height);                
                //const newWidth = initialWidth + deltaX;
                //const newHeight = initialHeight + deltaY;
                let newWidth, newHeight;
                const aspectRatio = initialWidth / initialHeight;
                newHeight = initialHeight + deltaY;
                newWidth = newHeight * aspectRatio;//只能等比例放大縮小

                //旋轉功能
                // 計算用戶拖動的角度
                //rotationAngle = Math.atan2(mouseX, mouseY);  //要以哪裡為中心點?

                //因為一直無法解決[不可動到retcanvas長寬]的問題，所以用爆理解法刪除圖層重新推一個新的長寬上去
                if(overlay.isRectCanvas && resizing){
                    overlayImages.splice(selectedOverlayIndex, 1);
                    const rectCanvas = document.createElement('canvas');
                    if(newWidth > 50){
                        rectCanvas.width = newWidth;
                        rectCanvas.height = newHeight;
                        const rectCtx = rectCanvas.getContext('2d');
                        drawRectangle(rectCtx,0, 0, rectCanvas.width, rectCanvas.height);                
                        overlayImages.push({
                            number:j, 
                            image: rectCanvas, 
                            x: overlay.x, 
                            y: overlay.y, 
                            width:rectCanvas.width, 
                            height:rectCanvas.height,
                            isRectCanvas: true,
                        });
                        j++;
                    }                    
               }else if(overlay.isText && resizing){ //文字功能
                    overlayImages.splice(selectedOverlayIndex, 1);
                    const textCanvas = document.createElement('canvas');
                    if(newWidth > 50){
                        textCanvas.width = newWidth;
                        textCanvas.height = newHeight;
                        const textCtx = textCanvas.getContext('2d');
                        textCtx.beginPath();
                        textCtx.font = `${newHeight}px 微软雅黑`;
                        textCtx.fillStyle = `${color}`;
                        textCtx.textBaseline = "top";
                        textCtx.textAlign = "left";
                        textCtx.fillText(overlay.text, 1, 1);  
                        textCtx.closePath();
                        overlayImages.push({
                            number:j, 
                            image: textCanvas, 
                            x: overlay.x, 
                            y: overlay.y, 
                            width:textCanvas.width, 
                            height:textCanvas.height,
                            isText:true,
                            text:overlay.text,
                        });     
                        j++;
                    }   
               }else{
                if(newWidth > 50){
                    overlay.image.width = newWidth;
                    overlay.image.height = newHeight;
                }
                }                            
                redrawCanvas();
            }                       
        }        
        /*-----------------------------------------------------Function-----------------------------------------------------*/
        //繪製圖像於畫布上
        function drawImageOnCanvas(image, x, y, width, height) {
            ctx.drawImage(image, x, y, width, height);
        }
        //清空畫布
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        function redrawCanvas() {
            clearCanvas();            
            // 計算等比例缩放比例
            const scale = canvas.width / backgroundImage.width;//Math.min(, canvas.height / backgroundImage.height)
            const scaledWidth = backgroundImage.width * scale;
            let scaledHeight = backgroundImage.height * scale;
            if(scaledHeight > canvas.height){
                canvas.height = scaledHeight;
            }      
            drawImageOnCanvas(backgroundImage, 0, 0, scaledWidth, scaledHeight);     console.log("owo");      
            for (const overlay of overlayImages) {    
                //drawRotate(overlay);                              
                const overlayWidth = overlay.image.width;
                const overlayHeight = overlay.image.height;        
                drawImageOnCanvas(overlay.image, overlay.x, overlay.y, overlayWidth, overlayHeight);                 
            }                   
        }
        //歷史紀錄只有在繪圖的時候可以用
        function displaySaveState (){
            document.getElementById('undo').style.display='block';
            document.getElementById('redo').style.display='block';
        }
        //歷史紀錄
        function saveState() {
            // 將當前繪圖狀態保存到歷史紀錄            
            history = history.slice(0, historyPointer + 1);console.log("save_historyPointer="+historyPointer);
            const currentState = ctx.getImageData(0, 0, canvas.width, canvas.height);
            history.push(currentState);
            historyPointer = history.length - 1;
            console.log("history.length="+history.length);console.log("historyPointer="+historyPointer);
        }

        function undo() {
            console.log("historyPointer="+historyPointer);
            if (historyPointer > 0) {
                historyPointer--;
                ctx.putImageData(history[historyPointer], 0, 0);console.log(history);
            }
        }

        function redo() {
            if (historyPointer < history.length - 1) {
                historyPointer++;
                ctx.putImageData(history[historyPointer], 0, 0);
            }
        }  
        /*function drawRotate(overlay){                
                // 將圖層的中心點設置為旋轉的軸心
                // 設定旋轉中心為圖像的中心
                const centerX = overlay.image.width / 2;
                const centerY = overlay.image.height / 2;

                ctx.translate(centerX, centerY);
                ctx.rotate((Math.PI / 180) * rotationAngle);
                ctx.clearRect(overlay.x,overlay.y,overlay.image.width, overlay.image.height);
                // 計算旋轉後的圖像區域的邊界框
                const rotatedBoundingBox = getRotatedBoundingBox(centerX, centerY, overlay.image.width, overlay.image.height, (Math.PI / 180) * 45);

                // 計算新的寬度和高度
                const rotatedWidth = rotatedBoundingBox.maxX - rotatedBoundingBox.minX;
                const rotatedHeight = rotatedBoundingBox.maxY - rotatedBoundingBox.minY;     
                overlay.image.width =  rotatedWidth;
                overlay.image.height = rotatedHeight;
                ctx.drawImage(overlay.image, 0, 0, overlay.image.width, overlay.image.height);
                // 恢復坐標系統
                ctx.rotate((Math.PI / 180) * -rotationAngle);
                ctx.translate(-centerX, -centerY);  
                
        }
        function getRotatedBoundingBox(centerX, centerY, width, height, angle) {
            const radians = angle;
            const cos = Math.abs(Math.cos(radians));
            const sin = Math.abs(Math.sin(radians));

            const newWidth = width * cos + height * sin;
            const newHeight = width * sin + height * cos;

            const minX = centerX - newWidth / 2;
            const minY = centerY - newHeight / 2;
            const maxX = centerX + newWidth / 2;
            const maxY = centerY + newHeight / 2;

            return { minX, minY, maxX, maxY };
        }
        function cropImage(){
            isCropping = true;                 
        }
        // 繪製可調整的裁切框
       /* function drawCropRect(cropX, cropY, cropWidth, cropHeight) {
            // 繪製遮罩
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, backgroundImage.width, backgroundImage.height);       
            // 將 globalCompositeOperation 設置為 'destination-out'
            ctx.globalCompositeOperation = 'destination-out';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(cropX, cropY, cropWidth, cropHeight);
            // 在裁切框的位置和尺寸上繪製一個白色的矩形
            ctx.fillStyle = 'white';
            ctx.fillRect(cropX, cropY, cropWidth, cropHeight);

            // 還原 globalCompositeOperation 為預設值
            ctx.globalCompositeOperation = 'source-over';
        }
        /*function zoomInImage(){
            if(isImageLoaded){
                const scale =  100;
                canvas.width = canvas.width + scale;
                canvas.height = canvas.height + scale;
                redrawCanvas();                
            }else{
                openNoticeModal();
            }                     
        }
        function zoomOutImage(){
            if(isImageLoaded){
                const scale =  100;
                canvas.width = canvas.width - scale;
                canvas.height = canvas.height - scale;
                redrawCanvas();
            }else{
                openNoticeModal();
            }                     
        }*/
         //編輯文字
         function EditText (e) {  
            if(isImageLoaded){
                isText = true;   
                isRectangle = false;
                isdrawLine = false;                
                ButtonActive();
                openModal(); 
            } else{
                openNoticeModal();
            }            
        };        
        function drawText(text, x, y){            
            const textCanvas = document.createElement('canvas');//沒有設置長寬的話預設長寬是 150 300
            const textCtx = textCanvas.getContext('2d');
            textCtx.beginPath();
            textCtx.font = `${fontSize}px 微软雅黑`;
            textCtx.fillStyle = `${color}`;
            textCtx.textBaseline = "top";
            textCtx.textAlign = "left";
            textCtx.fillText(text, 1, 1);  
            const textwidth = textCtx.measureText(text).width;
            textCtx.closePath();
            // 畫布大小似乎只能在一開始設置，所以再設一個畫布調整圖層長寬
            const textCanvas2 = document.createElement('canvas');
            textCanvas2.width = textwidth;//只能放在這個位置
            textCanvas2.height = fontSize;
            const textCtx2 = textCanvas2.getContext('2d');
            textCtx2.beginPath();
            textCtx2.font = `${fontSize}px 微软雅黑`;
            textCtx2.fillStyle = `${color}`;
            textCtx2.textBaseline = "top";
            textCtx2.textAlign = "left";
            textCtx2.fillText(text, 1, 1);  
            textCtx2.closePath();
            overlayImages.push({
                    number:j, 
                    image: textCanvas2, 
                    x: x - canvas.getBoundingClientRect().left, 
                    y: y - canvas.getBoundingClientRect().top, 
                    width:textCanvas2.width+1, 
                    height:textCanvas2.height+1,
                    isText:true,
                    text:text,
                 });
                j++;             
            redrawCanvas();
            // 將 textCanvas 轉換成 Data URL
            //const dataURL = textCanvas2.toDataURL();
            //const textimage = new Image();
            //textimage.src = dataURL;
            
        };     
        function openModal() {
            document.getElementById('TextModal').style.display = 'block';
        }     
        function addText() {
            const textInput = document.getElementById('textInput');
            const text = textInput.value.trim();
            // 將文字繪製成圖層
            drawText(text,canvas.width/2,canvas.height/2);
            // 關閉模態對話框
            isText = false;   
            document.getElementById('TextModal').style.display = 'none';
            //拿掉button active
            ButtonActive();
            // 清空輸入框
            textInput.value = '';
        }       
        function cancelText(){
            isText = false;   
            ButtonActive();
            document.getElementById('TextModal').style.display = 'none';
            textInput.value = '';
        }
        //畫矩形框        
        function IsdrawRectangle(){
            if(isImageLoaded){
                isRectangle = true;
                isText = false;
                isdrawLine = false;               
                ButtonActive();
            } else{
                openNoticeModal();
            }                     
        }
        function drawRectangle(canvas,startX, startY, endX, endY) {
            canvas.beginPath();
            canvas.rect(startX, startY, endX - startX, endY - startY);
            canvas.strokeStyle = `${color}`;
            canvas.lineWidth = 2;
            canvas.stroke();
            canvas.closePath();
        }
        //繪圖
        function IsdrawLine(){
            if(isImageLoaded){
                ctx.strokeStyle = '#000';//預設畫筆顏色為黑色
                isdrawLine = true;
                isRectangle = false;
                isText = false;   
                ButtonActive();   
                document.getElementById('CheckModal').style.display = 'block';             
            } else{
                openNoticeModal();
            }             
        }
        function CheckModal(){
            check = true;
            document.getElementById('CheckModal').style.display = 'none'; 
            isdrawLine = false;
            isDrawingLine = false;
            ctx.putImageData(history[historyPointer], 0, 0);
            // 保存繪製的圖層
            saveDrawingAsLayer();console.log(overlayImages); 
            redrawCanvas();  
            ButtonActive();                             
        }                
        function drawLine(context, x1, y1, x2, y2) {
            context.beginPath();   
            context.strokeStyle = `${color}`;
            context.lineWidth = 1;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.stroke();
            context.closePath();
        }
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        function drawLineOnTempCanvas(startX, startY, endX, endY) {
            tempCtx.beginPath();
            tempCtx.strokeStyle = `${color}`;
            tempCtx.lineWidth = 1;
            tempCtx.moveTo(startX, startY);
            tempCtx.lineTo(endX, endY);
            tempCtx.stroke();
            tempCtx.closePath();           
        }
        function saveDrawingAsLayer(x,y) {                 
            const layerCanvas = document.createElement('canvas');
            const layerCtx = layerCanvas.getContext('2d');           
            // 計算邊界
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                minX = Math.min(minX, point.x);
                minY = Math.min(minY, point.y);
                maxX = Math.max(maxX, point.x);
                maxY = Math.max(maxY, point.y);
            }
            layerCanvas.width = maxX - minX;
            layerCanvas.height = maxY - minY;
            //只切有繪畫的部分複製過去新畫布
            layerCtx.clearRect(0, 0, layerCtx.width, layerCtx.height);            
            layerCtx.drawImage(tempCanvas, minX - 1, minY - 1, (maxX - minX) + 5, (maxY - minY) + 5, 1, 1,maxX - minX,maxY - minY);            
            overlayImages.push({
                number: j,
                image: layerCanvas,
                x: minX,
                y: minY,
                width: layerCanvas.width,
                height: layerCanvas.height,
                isPath: true,
            });
            j++;
            // 清空臨時 Canvas 跟 points
            tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
            points.length = 0;   
        }     
        //加上active
        function ButtonActive(){
            const isTextElement =document.querySelector('#drawTextButton svg');
            const isRectangleElement =document.querySelector('#drawRectangle svg');
            const isdrawLineElement =document.querySelector('#drawLine svg');            
            if (isText){                
                isTextElement.classList.add("active");
            }else {
                isTextElement.classList.remove("active");
            }
            if (isRectangle){                
                isRectangleElement.classList.add("active");
            }else {
                isRectangleElement.classList.remove("active");
            }
            if (isdrawLine){                
                isdrawLineElement.classList.add("active");
                document.getElementById('CheckModal').style.display = 'block'; 
                displaySaveState();
            }else {
                document.getElementById('CheckModal').style.display = 'none'; 
                isdrawLineElement.classList.remove("active");
                CheckModal();
            }

        }
        //初始圖片
        function DrawNoImage(){
            ctx.beginPath();
            ctx.rect(0, 0, canvas.width - 0, canvas.height - 0);
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 15;                        
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo((canvas.width/5), canvas.height/8*5);
            ctx.lineTo((canvas.width/3)+(canvas.width/6), canvas.height/8*5);
            ctx.lineTo((canvas.width/6)+(canvas.width/6), canvas.height/8*3);//高點
            ctx.fillStyle = '#cccccc';
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(100 +(canvas.width/5.5), canvas.height/8*5);
            ctx.lineTo(100 + (canvas.width/2)+(canvas.width/5.5), canvas.height/8*5);
            ctx.lineTo(100 + (canvas.width/4)+(canvas.width/5.5), canvas.height/8*2);//高點
            ctx.fillStyle = '#cccccc';
            ctx.fill();
            ctx.beginPath();
            ctx.arc((canvas.width/4), (canvas.height/4), 30, 0, Math.PI * 2, true);
            ctx.fill();
            ctx.beginPath();
            ctx.font = '80px Arial';
            ctx.textAlign = "center";
            ctx.fillText("NO IMAGE", (canvas.width/2), canvas.height/8*7);
            ctx.closePath();
        }
        //跳提醒框
        function openNoticeModal() {
            document.getElementById('NoticeModal').style.display = 'block';
        }  
        function closeNoticeModal() {
            document.getElementById('NoticeModal').style.display = 'none';
        } 
        //插入圖層
        function addOverlayImage(){
            if (isImageLoaded){
                document.getElementById('addOverlayImage').style.display = 'block';
            }else{
                document.getElementById('addOverlayImage').style.display = 'none';
            }
        }        
        //顏色
        function colorModal(){
            document.getElementById('colorModel').style.display = 'block';
            //顏色監聽
            const colorElements = document.getElementsByClassName("color");
            for (const el of colorElements) {
                el.addEventListener("click", () => {
                    const computedStyle = window.getComputedStyle(el);
                    color = computedStyle.backgroundColor; console.log(color);
                    document.getElementById('colorModel').style.display = 'none';                    
            });}
        }                
        function saveImage() {
            var dataURL = canvas.toDataURL('image/png');
            var link = document.createElement('a');
            link.href = dataURL;
            link.download = 'canvas_image.png';
            //開始下載
            link.click();
        }
        /*---------------------------------------------------------------------------------------------------------------------*/                
        /*------------------------------------------------------功能圖示按鈕繪畫---------------------------------------------------------------------------*/        
        function drawScaleHandle(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, scaleHandleRadius, 0, Math.PI * 2);//arc(x, y, radius, startAngle, endAngle, anticlockwise) 
            ctx.fillStyle = 'white';
            ctx.fill();
            drawImageOnCanvas(zoomIcon, x-(scaleHandleRadius/2), y-(scaleHandleRadius/2), scaleHandleRadius, scaleHandleRadius);
            ctx.closePath();
        }

        function drawDeleteIcon(x, y) {
            ctx.beginPath();
            ctx.arc(x, y, deleteIconSize/2, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            drawImageOnCanvas(deletIcon, x-(deleteIconSize/2), y-(deleteIconSize/2), deleteIconSize, deleteIconSize);
            ctx.closePath();
        }

        function deleteSelectedOverlay() {
            if (selectedOverlayIndex !== -1) {
                overlayImages.splice(selectedOverlayIndex, 1);
                selectedOverlayIndex = -1;
                redrawCanvas();
            }
        }
        function drawCheck(x, y){
            ctx.beginPath();            
            ctx.fillStyle = 'white';
            ctx.fillRect(x, y, checkIconWidth, checkIconHeight);
            ctx.strokeStyle = 'rgba(0,0,0,.2)'
            ctx.lineWidth = 1;          
            ctx.strokeRect(x, y, checkIconWidth, checkIconHeight)
            //drawImageOnCanvas(deletIcon, x, y, checkIconWidth, checkIconHeight);
            ctx.closePath();
        }
        /*--------------------------------------------------------------------------------------------------------------------------------------------------*/
        backgroundImage.onload = function () {            
            clearCanvas();          
            //drawImageOnCanvas(backgroundImage, 0, 0, scaledWidth, scaledHeight);console.log(scaledHeight);
            redrawCanvas(); 
            isImageLoaded = true; 
            addOverlayImage();
        };

        overlayImage.onload = function () {
            drawImageOnCanvas(overlayImage, 50, 50, overlayImage.width, overlayImage.height);
        };

        document.getElementById('backgroundImage').addEventListener('change', function (e) {
            addOverlayImage();
            const file = e.target.files[0];
            if (file) {
                backgroundImage.src = URL.createObjectURL(file);// 設定圖像的src為選擇的圖像文件                
            }
        });
        //圖層
        var j = 0;
        document.getElementById('overlayImage').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (file) {
                const newOverlay = new Image();
                newOverlay.src = URL.createObjectURL(file);
                overlayImages.push({number:j, image: newOverlay, x: 50, y: 50 });j++;
                newOverlay.onload = function () {
                    redrawCanvas();
                };
        }}); 
        //功能切換關掉提醒框
        const colorElements = document.getElementsByClassName("menu__item");
            for (const el of colorElements) {
                el.addEventListener("click", () => {
                    if(!isText){
                        document.getElementById('TextModal').style.display = 'none';       
                    }                                 
            });}
        //裁切功能
        //document.getElementById('cropImage').addEventListener('click', cropImage);
        //document.getElementById('zoomIn').addEventListener('click', zoomInImage);
        //document.getElementById('zoomOut').addEventListener('click', zoomOutImage);
        //文字編輯功能
        document.getElementById('drawTextButton').addEventListener('click',EditText);
        document.getElementById('addText').addEventListener('click',addText);
        document.getElementById('cancelText').addEventListener('click',cancelText);
        //畫矩形框
        document.getElementById('drawRectangle').addEventListener('click',IsdrawRectangle);
        //繪圖
        document.getElementById('drawLine').addEventListener('click',IsdrawLine);
        document.getElementById('Check').addEventListener('click',CheckModal);
        //關閉提醒框
        document.getElementById('closeNoticeModal').addEventListener('click',closeNoticeModal);
        //顏色選單
        document.getElementById('color').addEventListener('click',colorModal);
        //歷史狀態
        document.getElementById('undo').addEventListener('click',undo);
        document.getElementById('redo').addEventListener('click',redo);

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mousemove', handleMouseMove);
        //canvas.addEventListener('click', handleMouseClick);
        //canvas.addEventListener('mouseenter', handleMouseEnter);
        //canvas.addEventListener('mouseleave', handleMouseLeave);

        
        }
    </script>
<style type="text/css">
    canvas {
        border: 1px solid white;
    }
    body{
        margin: 8px 30px !important;
        min-width: 825px;
    }
    .button{
        font-weight: 600;
        cursor: pointer;
        vertical-align: middle;
        letter-spacing: .3px;
        text-align: center;
        font-family: 'Noto Sans', sans-serif;
        width: 150px;
        height: 35px;letter-spacing: 2px;cursor: pointer;padding: 0;
        outline: none;
        border-radius:  0.3rem;        
    }
    .menu__border{
        content: "";
        z-index: -1;
        width: 4.2em;
        height: 4.2em;
        border-radius: 50%;
        position: absolute;
        transform: scale(0);
        transition: background-color var(--duration), transform var(--duration);
      }
    #zoomIn{
        position:relative;
    }
    #zoomIn:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '底圖放大';
    }
    #zoomOut{
        position:relative;
    }
    #zoomOut:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '底圖縮小';
    }
    #drawTextButton{
        position:relative;
    }
    #drawTextButton:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '插入文字';
    }
    #drawRectangle{
        position:relative;
    }
    #drawRectangle:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '繪製矩形';
    }
    #drawLine{
        position:relative;
    }
    #drawLine:hover::before{
        position: absolute;
        top: -15px;
        left: -73px;
        color: rgb(0, 0, 0);
        font-size: .8em;
        background: #ffffff;
        border: 1px solid rgba(0,0,0,.2);
        padding: 5px;
        border-radius: 5px;
        z-index: 99;
        content: '繪圖';
    }
    .active{
        color: #fbbb3c;
    }
    #redColor{
        width: 15px;
        height: 15px;
        border-radius: 25px;
        background-color: rgb(255, 31, 31);
        margin: 10px;
    }
    #orangeColor{
        width: 15px;
        height: 15px;
        border-radius: 25px;
        background-color: rgb(255, 154, 59);
        margin: 10px;
    }
    #yellowColor{
        width: 15px;
        height: 15px;
        border-radius: 25px;
        background-color: rgb(0, 0, 0);
        margin: 10px;
    }
    #greenColor{
        width: 15px;
        height: 15px;
        border-radius: 25px;
        background-color: rgb(71, 255, 111);
        margin: 10px;
    }
    #blueColor{
        width: 15px;
        height: 15px;
        border-radius: 25px;
        background-color: rgb(0, 17, 255);
        margin: 10px;
    }
    
    
    </style>
  </head>
  <body onload="draw();" >
    <!--排版一下-->
    <div style="margin: 0px auto 20px auto;max-width:900px;">
        <div style="width: 100%;height:100%;margin: 20px;    ">
            <div style="padding: 0px; vertical-align: middle;align-items: center;justify-content: space-between!important; display: flex; ">
                <div style="width: 50%; display: flex;">
                    <svg xmlns="http://www.w3.org/2000/svg"style=" color: #fbbb3c; padding: 25px;" width="40" height="40" fill="currentColor" class="bi bi-highlighter" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M11.096.644a2 2 0 0 1 2.791.036l1.433 1.433a2 2 0 0 1 .035 2.791l-.413.435-8.07 8.995a.5.5 0 0 1-.372.166h-3a.5.5 0 0 1-.234-.058l-.412.412A.5.5 0 0 1 2.5 15h-2a.5.5 0 0 1-.354-.854l1.412-1.412A.5.5 0 0 1 1.5 12.5v-3a.5.5 0 0 1 .166-.372l8.995-8.07.435-.414Zm-.115 1.47L2.727 9.52l3.753 3.753 7.406-8.254-2.905-2.906Zm3.585 2.17.064-.068a1 1 0 0 0-.017-1.396L13.18 1.387a1 1 0 0 0-1.396-.018l-.068.065 2.85 2.85ZM5.293 13.5 2.5 10.707v1.586L3.707 13.5h1.586Z"/>
                      </svg><h1 style="padding-top: 0; color: #fbbb3c;font-family: 'Noto Sans', sans-serif;"> Image Editor</h1>
                </div>                
                <div style="padding: 25px;width: 50%;display: flex; ">
                    <div >

                        <label class="button"style="background-color:#fbbb3c;border: none; color: black;padding-block: 1px;
                        padding-inline: 6px; ">上傳底圖<input type="file" id="backgroundImage" accept="image/*"style="width:1px;height:1px;"></label>
    
                        <button class="button"onclick="saveImage()" type="button" style="background-color: white; border:1px solid #fbbb3c;margin:0px 20px ;">完成輸出</button>
                         
                    </div>          
                </div>                
            </div>
            <div style="display: flex;    width: 20%;height: 18px;">                      
                <div class="menu" style="height: 40px; display: flex;margin:25px 0px 25px 0px;">
                    <div id="ButtonArea" style="padding: 0px 25px; display: flex;flex-direction: column!important; background-color: white;">
                        <div  style="padding: 10px;border:0px solid #fbbb3c; border-radius:  0.3rem;">
                            <label id="addOverlayImage">
                                <svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-images" viewBox="0 0 16 16" >
                                    <path d="M4.502 9a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z"/>
                                    <path d="M14.002 13a2 2 0 0 1-2 2h-10a2 2 0 0 1-2-2V5A2 2 0 0 1 2 3a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v8a2 2 0 0 1-1.998 2zM14 2H4a1 1 0 0 0-1 1h9.002a2 2 0 0 1 2 2v7A1 1 0 0 0 15 11V3a1 1 0 0 0-1-1zM2.002 4a1 1 0 0 0-1 1v8l2.646-2.354a.5.5 0 0 1 .63-.062l2.66 1.773 3.71-3.71a.5.5 0 0 1 .577-.094l1.777 1.947V5a1 1 0 0 0-1-1h-10z"/>
                                  </svg>
                                <input type="file" id="overlayImage" accept="image/*"style="width:0px;height:0px;">
                                </label>    
                        </div>
                        <!--<div style="padding: 10px;">
                            <label id="zoomIn"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-zoom-in" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                                <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                                <path fill-rule="evenodd" d="M6.5 3a.5.5 0 0 1 .5.5V6h2.5a.5.5 0 0 1 0 1H7v2.5a.5.5 0 0 1-1 0V7H3.5a.5.5 0 0 1 0-1H6V3.5a.5.5 0 0 1 .5-.5z"/>
                              </svg></label>       
                        </div>
                        <div  style="padding: 10px;">
                            <label id="zoomOut"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-zoom-out" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                                <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                                <path fill-rule="evenodd" d="M3 6.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5z"/>
                              </svg></label>       
                        </div>   -->  
                        <!--<div class="menu__item" style="padding: 10px;">
                            <label id="cropImage"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-scissors" viewBox="0 0 16 16">
                                <path d="M3.5 3.5c-.614-.884-.074-1.962.858-2.5L8 7.226 11.642 1c.932.538 1.472 1.616.858 2.5L8.81 8.61l1.556 2.661a2.5 2.5 0 1 1-.794.637L8 9.73l-1.572 2.177a2.5 2.5 0 1 1-.794-.637L7.19 8.61 3.5 3.5zm2.5 10a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0zm7 0a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0z"/>
                              </svg></label>       
                        </div>-->  
                        <div class="menu__item" style="padding: 10px;">
                            <label id="drawLine"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-highlighter" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M11.096.644a2 2 0 0 1 2.791.036l1.433 1.433a2 2 0 0 1 .035 2.791l-.413.435-8.07 8.995a.5.5 0 0 1-.372.166h-3a.5.5 0 0 1-.234-.058l-.412.412A.5.5 0 0 1 2.5 15h-2a.5.5 0 0 1-.354-.854l1.412-1.412A.5.5 0 0 1 1.5 12.5v-3a.5.5 0 0 1 .166-.372l8.995-8.07.435-.414Zm-.115 1.47L2.727 9.52l3.753 3.753 7.406-8.254-2.905-2.906Zm3.585 2.17.064-.068a1 1 0 0 0-.017-1.396L13.18 1.387a1 1 0 0 0-1.396-.018l-.068.065 2.85 2.85ZM5.293 13.5 2.5 10.707v1.586L3.707 13.5h1.586Z"/>
                              </svg></label>
                        </div>      
                        <div class="menu__item" style="padding: 10px;">
                            <label id="drawTextButton"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-fonts" viewBox="0 0 16 16">
                                <path d="M12.258 3h-8.51l-.083 2.46h.479c.26-1.544.758-1.783 2.693-1.845l.424-.013v7.827c0 .663-.144.82-1.3.923v.52h4.082v-.52c-1.162-.103-1.306-.26-1.306-.923V3.602l.431.013c1.934.062 2.434.301 2.693 1.846h.479L12.258 3z"/>
                              </svg></label>
                        </div>
                        <div class="menu__item" style="padding: 10px;">
                            <label id="drawRectangle"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-square" viewBox="0 0 16 16">
                                <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                              </svg></label>
                        </div>
                        <div class="menu__item" style="padding: 10px;">
                            <label id="undo" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-arrow-return-left" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M14.5 1.5a.5.5 0 0 1 .5.5v4.8a2.5 2.5 0 0 1-2.5 2.5H2.707l3.347 3.346a.5.5 0 0 1-.708.708l-4.2-4.2a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 8.3H12.5A1.5 1.5 0 0 0 14 6.8V2a.5.5 0 0 1 .5-.5"/>
                              </svg></label>
                        </div>
                        <div class="menu__item" style="padding: 10px;">
                            <label id="redo" style="display: none;"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-arrow-return-right" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M1.5 1.5A.5.5 0 0 0 1 2v4.8a2.5 2.5 0 0 0 2.5 2.5h9.793l-3.347 3.346a.5.5 0 0 0 .708.708l4.2-4.2a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 8.3H3.5A1.5 1.5 0 0 1 2 6.8V2a.5.5 0 0 0-.5-.5"/>
                              </svg></label>
                        </div>
                        <div class="menu__item" style="padding: 10px; position: relative;">
                            <label id="color"><svg xmlns="http://www.w3.org/2000/svg" width="25" height="25" fill="currentColor" class="bi bi-palette-fill" viewBox="0 0 16 16">
                                <path d="M12.433 10.07C14.133 10.585 16 11.15 16 8a8 8 0 1 0-8 8c1.996 0 1.826-1.504 1.649-3.08-.124-1.101-.252-2.237.351-2.92.465-.527 1.42-.237 2.433.07M8 5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m4.5 3a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3M5 6.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3"/>
                              </svg></label>
                            <div id="colorModel" style="position:absolute;left: 1px;border: 1px solid rgba(0,0,0,.2);border-radius: 15px;top: 49px;display: none;">
                                <div style="padding: 1px;">
                                    <div id="redColor" class="color"></div>
                                    <div id="orangeColor" class="color"></div>
                                    <div id="yellowColor" class="color"></div>
                                    <div id="greenColor" class="color"></div>
                                    <div id="blueColor" class="color"></div>
                                </div>                                
                            </div>
                        </div>
                        <div class="menu__border"></div>                        
                    </div>
                </div>
                
            </div>   
            <div style="width: 80%; margin:0px 80px;"><canvas id="myCanvas"style="border: 1px solid rgba(0,0,0,.2);border-radius:  0.3rem;max-width:100%; width:100%;"></canvas>
            <div style="width: 100%;position: relative;"><!--編輯文字的彈跳視窗-->
                <div  id="TextModal"  style="position: fixed;top: 40% ;left: 40%; display: none;z-index: 1060; text-align: center;   ">
                    <div style="position: relative;display: flex;flex-direction: column;width: 100%;pointer-events: auto;background-color: #fff;
                    background-clip: padding-box;
                    border: 1px solid rgba(0,0,0,.2);
                    border-radius: 0.3rem;padding: 0.3rem;
                    outline: 0;">
                        <div style="padding: 0.3rem;"><label for="textInput">請輸入文字：</label></div>
                        <div><input type="text" id="textInput"></div>
                        <div><button id="addText">確定</button></div>
                        <div><button id="cancelText">取消</button></div>
                    </div>
                    
                </div>
            </div>        
            <div style="width: 100%;position: relative;"><!--若未載入底圖跳出提醒-->
                <div  id="NoticeModal"  style="position: fixed;top: 40% ;left: 40%; display: none;z-index: 1060; text-align: center;   ">
                    <div style="position: relative;display: flex;flex-direction: column;width: 100%;pointer-events: auto;background-color: #fff;
                    background-clip: padding-box;
                    border: 1px solid rgba(0,0,0,.2);
                    border-radius: 0.3rem;padding: 0.3rem;
                    outline: 0;">
                        <div style="padding: 0.3rem;"><label for="textInput">請先加入底圖</label></div>
                        <div><button id="closeNoticeModal">確定</button></div>
                    </div>
                    
                </div>
            </div>      
            <div style="width: 100%;position: relative;"><!--若未載入底圖跳出提醒-->
                <div  id=""  style="position: fixed;top: 40% ;left: 40%; display: none;z-index: 1060; text-align: center;   ">
                    <div style="position: relative;display: flex;flex-direction: column;width: 100%;pointer-events: auto;background-color: #fff;
                    background-clip: padding-box;
                    border: 1px solid rgba(0,0,0,.2);
                    border-radius: 0.3rem;padding: 0.3rem;
                    outline: 0;">
                        <div style="padding: 0.3rem;"><label for="textInput">繪圖完成</label></div>
                        <div><button id="">確定</button></div>
                        <div><button id="">取消</button></div>
                    </div>
                    
                </div>
            </div>    
            <div style="width: 100%;position: relative;"><!--若未載入底圖跳出提醒-->
                <div  id="CheckModal"  style="position: fixed;top: 20% ;left: 80%; display: none;z-index: 1060; text-align: center;   ">
                    <div style="position: relative;display: flex;flex-direction: column;width: 100%;pointer-events: auto;background-color: #fff;
                    background-clip: padding-box;
                    border: 1px solid rgba(0,0,0,.2);
                    border-radius: 0.3rem;padding: 0rem;
                    outline: 0;">
                        <div><button id="Check"style="border:none; padding: 0.3rem 0.5rem;">繪圖完成 v </button></div>
                    </div>
                    
                </div>
            </div>   
            
            
            <!--插入游標圖案--不使用了
            <div class="mouseImg">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-cursor-text" viewBox="0 0 16 16">
                    <path d="M5 2a.5.5 0 0 1 .5-.5c.862 0 1.573.287 2.06.566.174.099.321.198.44.286.119-.088.266-.187.44-.286A4.165 4.165 0 0 1 10.5 1.5a.5.5 0 0 1 0 1c-.638 0-1.177.213-1.564.434a3.49 3.49 0 0 0-.436.294V7.5H9a.5.5 0 0 1 0 1h-.5v4.272c.1.08.248.187.436.294.387.221.926.434 1.564.434a.5.5 0 0 1 0 1 4.165 4.165 0 0 1-2.06-.566A4.561 4.561 0 0 1 8 13.65a4.561 4.561 0 0 1-.44.285 4.165 4.165 0 0 1-2.06.566.5.5 0 0 1 0-1c.638 0 1.177-.213 1.564-.434.188-.107.335-.214.436-.294V8.5H7a.5.5 0 0 1 0-1h.5V3.228a3.49 3.49 0 0 0-.436-.294A3.166 3.166 0 0 0 5.5 2.5.5.5 0 0 1 5 2zm3.352 1.355zm-.704 9.29z"/>
                  </svg>
            </div>-->
            </div>
        </div>
    </div>

    

    

    
  </body>
</html>